{"meta":{"title":"hawk的博客","subtitle":"雾恋星空","description":"华工11级计联 毕业就职腾讯游戏。","author":"HawkLin","url":"http://yoursite.com"},"posts":[{"title":"FFMpegStudy","slug":"FFmpegStudy","date":"2020-10-13T10:25:18.000Z","updated":"2020-10-13T02:27:21.193Z","comments":true,"path":"2020/10/13/FFmpegStudy/","link":"","permalink":"http://yoursite.com/2020/10/13/FFmpegStudy/","excerpt":"知识搜索总的：https://blog.csdn.net/leixiaohua1020/article/details/15811977\n一、音视频流基础1、互联网视频文件解协议网络传播用的是流媒体协议 HTTP RTMP MMS 解析为标准的相应的封装格式数据\n解封装分离成音频流压缩编码数据 和 视频流压缩编码数据 例如FLV解封装为H.264编码的视频码流 和 AAC编码的音频码流\n解码音视频解码为非压缩的视频、音频原始数据 音频的压缩编码标准包含  AAC  MP3  AC-3等  视频的压缩编码标准有H.264 MPEG2  VC-1压缩编码的视频数据输出成非压缩的颜色数据  YUV420p  RGB \n音视频同步同步解码出来的视频和音频数据 并将视频 音频数据送至 显卡和声卡","text":"知识搜索总的：https://blog.csdn.net/leixiaohua1020/article/details/15811977 一、音视频流基础1、互联网视频文件解协议网络传播用的是流媒体协议 HTTP RTMP MMS 解析为标准的相应的封装格式数据 解封装分离成音频流压缩编码数据 和 视频流压缩编码数据 例如FLV解封装为H.264编码的视频码流 和 AAC编码的音频码流 解码音视频解码为非压缩的视频、音频原始数据 音频的压缩编码标准包含 AAC MP3 AC-3等 视频的压缩编码标准有H.264 MPEG2 VC-1压缩编码的视频数据输出成非压缩的颜色数据 YUV420p RGB 音视频同步同步解码出来的视频和音频数据 并将视频 音频数据送至 显卡和声卡 2、视频数据处理(一帧一帧的取数据)(裸数据)https://blog.csdn.net/leixiaohua1020/article/details/50534150 YUV 420p 256x256x1byte 这个是Y分量亮度 色度U=128x128x1byte V=128x128x1byte 采样密度不一样 YUV 444p 256x256x1byte 这个是Y分量亮度 色度U=256x256x1byte V=256x256x1byte 采样密度一样 YUV 420p去掉颜色 memset(pic+wxh,128,wxh/2); 色度分量取值0至255，无色对应的就是128 YUV420P像素数据的亮度减半 取出Y 然后除以2 YUV420P格式的灰阶测试图 就是生成YUV（0，128,128）、（28，128,128）….（255，128,128） PSNR：取值通常情况下都在20-50的范围内，取值越高，代表两张图像越接近，反映出受损图像质量越好。MSE=两张图的差值的平方均值.png) 类似于YUV420的排布格式叫Planar 类似RGB24的排布格式叫Packed 将RGB24格式像素数据封装为BMP图像：BMP采用的是小端（Little Endian）存储方式。这种存储方式中存储的先后顺序为B、G、R。给RGB格式文件加BMP头和将RB数据调换 将RGB24格式像素数据转换为YUV420P格式像素数据 彩条侧视图 3、视音频数据处理入门：PCM音频采样数据处理(裸数据) 分离PCM16LE双声道音频采样数据的左声道和右声道16LE代表16bit 就是2byte LE是小端数据格式：2Byte(左声道)2Byte(右声道)2Byte(左声道)2Byte(右声道) 将PCM16LE双声道音频采样数据中左声道的音量降一半这个就是读取数据 每4bytes读取 然后把前2bytes的值除以2 将PCM16LE双声道音频采样数据的声音速度提高一倍简单的就是采样除以2 间隔着采样左右声道 将PCM16LE双声道音频采样数据转换为PCM8音频采样数据除以 2^8次方 来处理 将从PCM16LE单声道音频采样数据中截取一部分数据 将PCM16LE双声道音频采样数据转换为WAVE格式音频数据该格式的实质就是在PCM文件的前面加了一个文件头 4、视音频数据处理入门：H.264视频码流解析(压缩)每个NALU之间通过起始码进行间隔 起始码分成两种 0x000001 0x00000001通过搜索搜索起始码 得到NALU 5、视音频数据处理入门：AAC音频码流解析(压缩)其中ADTS通过syncword 进行间隔 6、视音频数据处理入门：FLV封装格式解析FLV是由一个FLV Header和 一个一个Tag组成 7、视音频数据处理入门：UDP-RTP协议解析 二、FFMpeg1、FFmpeg程序的使用ffmpeg.exe 用于转码的程序例子：ffmpeg -i input.avi -b:v 640k output.tsffplay.exe 用于播放的程序例子：ffplay test.aviffprobe 用于查看文件格式的程序 2、FFmpeg库的使用：视频播放器2.1 ffmpeg 库的配置 demo工程https://download.csdn.net/detail/leixiaohua1020/5122959使用了libavformat libavcodec 实际只使用libavcodec就可以完成解码 2.2 介绍下ffmpeg的一些函数 avcodec_init()引入头文件 libavcodec/avcodec.h一般在程序启动或模块初始化时调用 av_register_all()注册多种音频视频格式的解码器 并注册各种文件的解码复用器 avformat_alloc_context() 2.3 相关结构体的研究 AVFrame 包含码流参数较多的结构体 在avcodec.hAVFrame 存储原始数据 非压缩数据 视频就是YUV RGB 音频就是PCMdata：解码后的原始数据linesize:一行的大小 未必就是图像的宽 一般大于图像宽width、height: 视频帧宽高 1920x1080 1280x720nb_samples: 一个AVFrame可能包含多个音频帧 这里标记为几个format:解码后的格式类型 YUV420 YUV422 RGB24key_frame:是否是关键帧enum AVPictrureType pic_type 帧类型 I B PAVRational sample_aspect_ratio:宽高比pts:时间戳coded_picture_number:编码帧序号dispaly_picture_numer:显示帧序号QP表 AVFormatContext 包含码流数据较多的输入数据的缓存文件名时长比特率元数据 AVCodeContextcodec_type:编码器类型 VIDEO AUDIO DATA SUBTITLE ATTACHMENT NBcodec：才有的解码器bit_rate:平均比特率extradata:特定编码器包含的附加信息time_base:width、heightrefs 运动参考帧的个数sample_rate:采样率 音频channels:声道数sample_fmt：采样格式profile:ACC MPEG2 H.264 AVIOContext 管理输入输出的结构体 缓存开始位置 缓存大小（默认32768） 当前指针读取到的位置 opaque：URLContext AVCodec AVStreamindexcodectime_baseAVPacket attached_pic Mp3附带图片 AVPacket 存储压缩编码数据相关信息压缩编码的数据 H.264 1个AVPacket的data对应一个NALsize data的大小pts 时间戳dts 解码时间戳 3、FFmpeg库的使用：音频播放器学习最简单的播放器https://blog.csdn.net/leixiaohua1020/article/details/10528443 4、FFmpeg —— ffplay5、FFmpeg：编码6、ffmpeg源代码分析7、FFmpeg其它几个类库","raw":null,"content":null,"categories":[],"tags":[]},{"title":"VSCode之Shader插件","slug":"VSCode之Shader插件","date":"2020-10-12T22:45:18.000Z","updated":"2020-10-13T02:27:21.193Z","comments":true,"path":"2020/10/12/VSCode之Shader插件/","link":"","permalink":"http://yoursite.com/2020/10/12/VSCode之Shader插件/","excerpt":"Shader插件 VSCode0、推荐原因可以i很快的验证一些渲染问题。","text":"Shader插件 VSCode0、推荐原因可以i很快的验证一些渲染问题。 1、ShaderToy网址https://www.shadertoy.com/view/4dXGR4 2、VSCode插件2.1、安装 2.1、Hello world 新建一个文件 test.shader 里面写如下代码：123456789101112131415161718192021222324void main() &#123; float time = iGlobalTime * 1.0; vec2 uv = (gl_FragCoord.xy / iResolution.xx - 0.5) * 8.0; vec2 uv0 = uv; float i0 = 1.0; float i1 = 1.0; float i2 = 1.0; float i4 = 0.0; for (int s = 0; s &lt; 7; s++) &#123; vec2 r; r = vec2(cos(uv.y * i0 - i4 + time / i1), sin(uv.x * i0 - i4 + time / i1)) / i2; r += vec2(-r.y, r.x) * 0.3; uv.xy += r; i0 *= 1.93; i1 *= 1.15; i2 *= 1.7; i4 += 0.05 + 0.1 * time * i1; &#125; float r = sin(uv.x - time) * 0.5 + 0.5; float b = sin(uv.y + time) * 0.5 + 0.5; float g = sin((uv.x + uv.y + sin(time * 0.5)) * 0.5) * 0.5 + 0.5; gl_FragColor = vec4(r, g, b, 1.0);&#125; 3、右键预览","raw":null,"content":null,"categories":[],"tags":[]},{"title":"自动构建博客","slug":"GameObjectInstantiate","date":"2019-08-15T14:44:39.000Z","updated":"2020-10-13T02:28:06.953Z","comments":true,"path":"2019/08/15/GameObjectInstantiate/","link":"","permalink":"http://yoursite.com/2019/08/15/GameObjectInstantiate/","excerpt":"","text":"步骤调用堆栈：GameObject.InstantiateObject Internal_CloneSingle","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Unity骨骼动画学习","slug":"Unity骨骼动画学习","date":"2019-08-13T21:44:39.000Z","updated":"2020-10-13T02:28:06.953Z","comments":true,"path":"2019/08/13/Unity骨骼动画学习/","link":"","permalink":"http://yoursite.com/2019/08/13/Unity骨骼动画学习/","excerpt":"一、动画分类：骨骼动画 关节动画 关键帧动画关键帧：存储关键帧数值 其他插值得到。计算量少 表现被限制 内存大关节动画：多个Mesh  现在是多个Mesh骨骼动画：Bone和Mesh 多层父子关系。 有骨骼层次数据  网络Mesh数据  网络蒙皮数据 ","text":"一、动画分类：骨骼动画 关节动画 关键帧动画关键帧：存储关键帧数值 其他插值得到。计算量少 表现被限制 内存大关节动画：多个Mesh 现在是多个Mesh骨骼动画：Bone和Mesh 多层父子关系。 有骨骼层次数据 网络Mesh数据 网络蒙皮数据 二、骨骼动画分析1、骨骼数量通常有个限制 302、盆骨作为根骨骼3、两个脚之间的中点作为原点 三、看一个换肤 demo代码github:https://github.com/zouchunyi/UnityAvater有个注释的github:https://github.com/GITHUB243884919/ChangeEQForUnity 博客：https://blog.uwa4d.com/archives/avartar.html 1、大致看下这个Demo 换武器 换衣服 换头饰 2、代码分析 2.1 Main.csMain.cs就是UI交互代码 2.2 CharacterController先把各个部分组合到一起 然后可以换头、播放动作等操作看下这个构造函数：UCharacterController 2.3 CombineSkinnedMgr核心代码传入了骨骼 和 每个部件的SkinnedMeshRenderer这里的纹理合并不是最优的 在mono C++ 显存都有占用 而且纹理格式是RGBA 不是压缩格式","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"骨骼","slug":"骨骼","permalink":"http://yoursite.com/tags/骨骼/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"}]},{"title":"自动构建博客","slug":"自动构建博客","date":"2019-08-13T21:44:39.000Z","updated":"2020-10-13T02:28:06.953Z","comments":true,"path":"2019/08/13/自动构建博客/","link":"","permalink":"http://yoursite.com/2019/08/13/自动构建博客/","excerpt":"","text":"步骤1、新建目录 2、在目录里面新加文章目录名字跟文章名字一样 3、MovePost.py 脚本拷贝到_posts中4、Travis 构建里面hexo publish文章5、部署到gitpage中","raw":null,"content":null,"categories":[{"name":"随笔记录","slug":"随笔记录","permalink":"http://yoursite.com/categories/随笔记录/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"CppReview","slug":"CppReview","date":"2018-05-11T20:07:05.000Z","updated":"2020-10-13T02:27:21.193Z","comments":true,"path":"2018/05/11/CppReview/","link":"","permalink":"http://yoursite.com/2018/05/11/CppReview/","excerpt":"复习C++回顾复习下C++的一些知识~重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：http://blog.csdn.net/linyanhou/article/details/40153521","text":"复习C++回顾复习下C++的一些知识~重新看下大学时候自己写的博客，做了些实验来验证C++的知识点：http://blog.csdn.net/linyanhou/article/details/40153521 1、虚函数实现机制Class A(){ virtual void Ax(){}; virtual void Ay(){};};Class D:A{ virtual void Ax(){}; virtual void Ax1(){}; virtual void Ay1(){};}; A a;D d; a对象包含一个虚函数表的指针vptrA:存了Ax、Ay函数的函数地址d对象包含一个虚函数表的指针vptrD:存了Ax、Ay、Ax1、Ay1函数的函数地址Ax是指的是继承类里面的 Ax 多重集成 A、B（两个都包含虚函数的类） 那么则会有两个虚表 用下面代码看下虚表存在哪里：class A{public : virtual void test(){};};int main(){ A a1; A a2; cout&lt;&lt;&amp;a1&lt;&lt;endl; cout&lt;&lt; sizeof (a1)&lt;&lt;endl; cout&lt;&lt;&amp;a2&lt;&lt;endl; cout&lt;&lt; sizeof (a2)&lt;&lt;endl;} 输出结果跟 &amp;a1 a1._vfptr 比较发现是一样的，sizeof(a1)是4字节 见大学写的博客：http://blog.csdn.net/linyanhou/article/details/40153521 2、构造函数调用顺序基类构造函数 之后成员对象的构造函数 之后派生类的构造函数下面实验是说明成员对象在初始化列表初始化的话是先于本身的构造函数的：class C{public : C() { printf( “C constructor\\n” ); } C( int i) { printf( “have num %d constructor\\n” ,i ); }};class A{public : C c; A():c(123){printf( “A constructor\\n” );c = C ();}; virtual void foo(){ printf( “Base Class Constructor.” ); }};int main(){ A a;}输出是：第一先是这句：A():c(123) 调用了 C 的参数构造函数 输出have num 123 constructor第二是这句：printf( “A constructor\\n” ); 输出A constructor第三句是这句：c = C (); 调用 C 的默认构造函数C constructor 3、union 还有大端小端的问题利用 union 来看是否是大小端union T{ char s[2]; int a;}; int main(){ T t; (1) 打印 t.s[0] t.s[1] t.a 的地址得知 &amp;t.s[0] = &amp;（t.a） 结论：char数组的0位地址是int的地址向左对齐 (2) t.a=0; t.s[0]=10; t.s[1]=1; printf( “%d\\n” ,t.a); **（1）定义分析：** 大端 高位存在低地址 例如： int 4字节 byte[0] byte[1] byte[2] byte[3] 假设这个 int的16进制是 0x12 34 56 78 地址递增 int 0x12 34 56 78 那么 低地址byte[0]存整数的最高位0x12 byte[1]=0x34 byte[2]=0x56 byte[3]=0x78 **（2）输出分析：** 输出是266，所以这个 int a 的16进制：0x00 00 01 0A 0A是整数低位，t.s[0]是低地址 高位存在高地址 【注】：修正原来的文章 我当时实验的电脑是小端 高位存在高地址 } 4、verctor 的内存分配：回顾下自己大学的博客 久不用就容易忘记 还是需要不断的学习http://blog.csdn.net/linyanhou/article/details/40067727 不断 push vectro 内存分配 capacityfor( int i=0;i&lt;200;i++){ v.push_back(a1);}不断 push 然后查看 capacity:12346913源码：if (_Capacity &lt; size() + _Count)//当前空间不足，需要扩容 { // not enough room, reallocate _Capacity = max_size() - _Capacity / 2 &lt; _Capacity ? 0 : _Capacity + _Capacity / 2; // try to grow by 50%，扩容50% if (_Capacity &lt; size() + _Count)//扩容50%后依然不够容下，则使容量等于当前数据个数加上新增数据个数 构造函数的调用过程：详细看我之前写的博客：http://blog.csdn.net/linyanhou/article/details/40067727 如何使用提高性能：为了比较，我们用了三种方式来把100个数据存入vector中，分别是：1、直接每次push_back();2、使用resize()提前分配100个空间，然后push_back;3、使用reserve提前分配100个存储空间。 速度（快到慢）：3&gt;2&gt;1 【注】：reserve分配空间 resize()会调用构造函数","raw":null,"content":null,"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"unityAdsAdapter","slug":"unityAdsAdapter","date":"2018-05-11T20:07:05.000Z","updated":"2020-10-13T02:27:21.285Z","comments":true,"path":"2018/05/11/unityAdsAdapter/","link":"","permalink":"http://yoursite.com/2018/05/11/unityAdsAdapter/","excerpt":"一、效果方案0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。","text":"一、效果方案0、适配方案就是让美术出一张图 然后在各个机型都不会变形，但是会被拆切了一部分。因为会有裁剪所以需要让美术知道哪部分是可能会被裁剪掉的。 1、适配机型的依据：http://nb.oa.com/AdaptionData/index/ 2、适配方案如下：出图是出iphonex的图，全屏图是473*1024 3、全屏图的换算公式： （1）如果我们考虑最长的屏幕是iphonex 确定好以这个来出图 其他的手机屏幕去适配这个的是会只会可能被拆检上下的区域 （2）把24361125 等比例缩放成 1024473（有0.1的细微拉升 基本无感知） （3）把其他屏幕换算,等比拉升：deviceH/deviceW = deviceHScale/473所以deviceHScale = 设备高宽比*473 （4）算出上限 下限 （5）选线，告诉美术这些线的意义： iphonex就是出图的结果 第一条线就是iphone6也是大部分安卓机的比例 第二条是需要适配的安卓机的最小比例 第三条线就是iphone4的比例 总结，美术要考虑第一条线（iphone6）来出图 因为这是大部分机的尺寸，然后去重要内容（文字）要放在第二条线以内，第三条线可以不考虑那么多。 4、活动图的换算公式：了解个概念：matchWidthOrHeight等于1的时候：缩放宽度等于0的时候：缩放高度 我们只有0、1情况 代码中会动态改变这个值 所以换算公式也需要12345678if (Screen.width / this.m_canvasScaler.referenceResolution.x &gt; Screen.height / this.m_canvasScaler.referenceResolution.y) &#123; this.m_canvasScaler.matchWidthOrHeight = 1.0f; &#125; else &#123; this.m_canvasScaler.matchWidthOrHeight = 0f; &#125; （1）算出在设备里面的广告图高度（2）类似全屏图计算 三、转PVR、ETC1、目前的比例是按照高度是1024来做的后续如果为了省内存或者是省流量pvr就可以做成这样，左边是原图右边是Alpha通道pvr右侧取得是r g b其中一个值 除了广告图可以左右拆分alpha 其他图集也是可以这样做的。 2、需要这些工作（1）代码中是把www.bytes转RGBA32 存储宽高信息需要知道 原来的宽高 全屏则是473*1024（2）分平台下载 etc pvr（3）修改材质 shader 需要修改uv（4）给美术使用的转图工具（5）给策划使用的上传工具","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"手游中的文件格式和纹理格式","slug":"picture-texture","date":"2017-09-10T20:32:15.000Z","updated":"2020-10-13T02:27:21.281Z","comments":true,"path":"2017/09/10/picture-texture/","link":"","permalink":"http://yoursite.com/2017/09/10/picture-texture/","excerpt":"\n我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，本文就来梳理一下这些名字，作简要的解释。\n\n一、首先我们来分类一下1、文件格式：图片在硬盘中的格式2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。3、压缩算法：etc（本文会详细解释此算法）、pvr等","text":"我们看到png、jpg、bmp 然后又看到RGBA-4444、RGBA-5551、RGB-888，然后看到什么pvr、pkm、etc等等 这些名字很多很多，看到会有些熟悉但是又分不清楚，本文就来梳理一下这些名字，作简要的解释。 一、首先我们来分类一下1、文件格式：图片在硬盘中的格式2、纹理格式：这里我认为是：包括了 在内存里面的格式和在传给GPU的纹理。3、压缩算法：etc（本文会详细解释此算法）、pvr等 二、稍微深入的讲解1、文件格式： 我们说的png、jpg、bmp指的是文件格式，就是图片在硬盘里面存储的格式，或者是手机的存储里面的格式，游戏的资源的格式。 引用百度百科里面的话：图像格式即图像文件存放的格式，通常有JPEG、TIFF、RAW、BMP、GIF、PNG。PNG：提取《PNG文件格式详解》这篇文章的解释：png文件由PNG文件标志（文件头）、3个以上的PNG的数据块（Chunk）按照特定的顺序组成 PNG文件标志 Chunk … Chunk 下面这个表格是数据块chunk的内容（主要的chunk） 数据块符号 数据块名称 多数据块 位置限制 IHDR 文件头数据块 否 第一块 PLTE 调色板数据块 否 在IDAT之前 IDAT 图像数据块 是 与其他IDAT连续 IEND 图像结束数据 否 最后一个数据块 2、纹理格式 纹理格式 解释 其他 RGBA8888 RGBA 各占8位bit， 一个像素就4byte （1）常用地方：整个场景背景图片 大量的渐变色图片 （2）OpenGL ES生成纹理在生成纹理时大小会自动扩展成2的幂次方。不足自动向下调整 BGRA8888 跟RGBA8888顺序不一样 RGBA4444 RGBA 各占4位bit 一个像素就2byte RGB888 这个相比第一种 RGBA8888 没有 alpha通道 用在没有透明度的图片 游戏背景图片。 RGB565 这个是高品质的16位纹理 也是没有透明度 RGBA5551 透明度只有0 和 1 没有渐变的图片 PVRTC2 iphone 的图片芯片 对一种称为 PVRTC 的压缩技术提供硬件支持所有颜色和透明度占2个字节(品质可能有点低) PVRTC4 所有颜色和透明度占4个字节,在ios上基本都用这个格式 (iOS产品专用) PVRTC2_NOALPHA RGB占用2个字节，没用ALPHA通道 PVRTC4_NOALPHA RGB占用4个字节，没用ALPHA通道 ETC1 安卓常用的压缩格式 ETC2 安卓常用的压缩格式 3、压缩算法Android设备 首先，android设备一般使用ETC1压缩 一种有损的图像压缩方式：ETC1是opengl2.0 压缩之后每个像素占用4bit 压缩之后的格式为KTX或者PKM 前者支持存储多纹理 后者只支持单纹理1024的RGBA32占用内存4M 如果是etc1的压缩之后就是0.5METC1的缺点是不支持Alpha通道 不支持有透明度的图片压缩 ETC2解决了Alpha通道 但是它是Opengl3.0标准 考虑到2.0设备市场占用率 一般使用ETC1【附】止于 2017 年 8 月 8 日在安卓开发者中心看到| OpenGL ES Version| Distribution|| :——– | ——–:|| 2.0 | 37.6%|| 3.0 | 45.6%|| 3.1| 16.8%| 算法过程解释 ETC压缩算法翻译：读这篇文章可以了解 用中文尽可能表达一遍1.总体了解下：ETC的压缩单元是4x4的像素块，会把一个4x4的像素块压缩成一个64bit中。 2.下面介绍几张表： encode decode过程会使用到的 1）像素表（源表）下图就是这个4x4的像素块的表 每个pixel如果用RGBA8888表示 那就是4x4x4 64字节| pixel| pixel| pixel| pixel|| :——– | :——– || a |e |i| m|| b |f |j| n|| c |g |k| o|| d |h |l| p|2）压缩后表（结果表） 下图就是压缩后的64bit 每个bit要么是0 要么是1：| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit| bit|| :——– | :——– ||63|62|61|60|59|58|57|56|55|54|53|52|51|50|49|48|| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0||47|46|45|44|43|42|41|40|39|38|37|36|35|34|33|32|| 0| 0| 0| 0| 0| 0| 0| 0| table cw 1| table cw 1| table cw 1| table cw 2| table cw 2| table cw 2| diff bit| flip bit||31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0||15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 3）下面这些表示预存储的表 就是不占文件大小 decode encode过程 调用算法使用的表3.1）像素差值表 待会会来这里索引取值3.2）间隔表 待会也会来这里索引取值 3.下面正式介绍算法过程： encode过程①第32bit是flipbit如果这个bit是0 那么这个块分成2个2x4的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）如果这个bit是1 那么这个块分成2个4x2的块 如下： 每个块称为subblock（64bit这里用了1个剩下63个）②分块之后计算这两个块的颜色均值，存储颜色均值的方法有两种，用第33bit（diffbit）来表示用了哪种存储颜色均值的方法，每个subblock用12bits存储颜色均值 两个block就是24bits （均值用了24bits 用一个bit表示用了哪个存储颜色均值的方法 所以用了25bit 现在剩下38bits）如果第33bit（diffbit）是0 那么颜色均值方法如下：下图是用63到40（一共24bits）来存均值，图中标注了 63-60是给R1 55-52是给G1 47-44是给B1举例子,如果 R1 = 14 =1110b, G1 = 3 = 0011b and B1 = 8 = 1000b, 那么subblock的均值的红色部分是11101110b = 238 绿色部分 00110011b = 51 蓝色部分10001000b = 136.如果第33bit（diffbit）是1 那么颜色均值方法如下：下图是用63到40（一共24bits）来存颜色均值，图中标注了 63-59是给R1 55-51是给G1 47-43是给B1举个例子，如果 R1’ = 28 = 11100b, 那么subblock的均值的红色部分是11100111b = 231. 同理绿色部分G1’ = 4 = 00100b 蓝色部分B1’ = 3 = 00011b, 结果是 00100001b = 33 and 00011000b = 24这里有点特殊的是第二个块 R、G、B分别只有3bits，也是举例子：如果 R1’ = 28 = 11100b R2 = 100b = -4, 那么28+(-4)=24 = 11000b, 所以第二个块的R是 11000110b = 198. 同理可得G2 B2③我们先看到39 38 37 bit 三个bit用于确定是用哪个像素差值表 看到2.3.1的表 有8行 刚好3个bit可以确定是哪行 如果39 38 37 bit是010 那个是2 也就是用-29 -9 9 29这行 同理36 35 34 bit然后现在还有32个bit没有解释，剩下的是第31到第0bit， 我们最原始的像素是16个像素 现在每个像素只有2bit了 我们看这个表可以查询一个映射关系下面的表 例如像素d 对应的是19bit和3bit 举个例子 19bit是1 3bit是0 那么合起来就是01 我们看到间隔表（2.3.2的表） 对应的是b 刚刚我们的像素差值行是[-29 -9 9 29] 所以得到的值是29 假设我们的均值颜色是(231, 8, 16)那个对应的颜色就是(231+29, 8+29, 16+29) 如果越界255 则归为255 所以是(255, 37, 45) 上面的过程归结到流程图中 12345678910&gt;st=&gt;start: Start&gt;e=&gt;end&gt;op1=&gt;operation: ①4x4的像素块是分成2个2x4的&gt;还是2个4x2的 横切还是竖切？&gt;op2=&gt;operation: ②存储颜色均值是用哪种方法？&gt;op3=&gt;operation: ③使用table codeword哪个表？&gt;op4=&gt;operation: ③16个像素点的像素值跟均值的差值是多少？查表填相应数值&gt;st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e&gt;&gt; Ios设备ios设备中采用的图像格式一般是pvr 也是有损的图像压缩方式pvr压缩分成 pvrtc2 pvrtc4一个是2bits 一个是4bits除了压缩内存的优势还可以直接被显卡读取 载入速度更快 缺点是需要PowerVR芯片支持 目前ios设备都能完美支持 pvr的格式 算法原理pvr文件分成两部分| Header| Texture Data|| :——– | ——–:|| 44 (pvr1) or 52 bytes(pvr2)| 大于等于0bytes |算法原理比较高深 看不懂 也没有细看文章中的这副图 可以看到 跟ETC有点像 也是把4x4的pixel压缩到64bits里面 16bit是Base ColourB15bit是Base ColourB 还有个Mod Mode存一个bit 剩下的32bits是 Modulation Data每2bits对应一个像素点 对应关系如下： 4、从上面的1文件格式、2纹理格式、3压缩算法 应用到一些问题上：下面图片是一张图片的三个格式 png32 pvr pkm 第一个问题，理论上png32 512x512 大小应该是512x512x4bytes（1M） 但是这里显示217km?这个是因为png32文件也有自己的压缩，这张png32在内存里面用的是1M 但是文件格式有自己的无损压缩方法 所以小于1M pvr的是一个像素4bits 所以应该是 512x512x0.5bytes=128km 这里是129kb因为pvr分为 Header和Texture Data 多出的1k byte存头部 参考引用：pvr和png内存占用http://blog.csdn.net/kaitiren/article/details/8054856http://www.cnblogs.com/xulidong/p/5681351.html 纹理格式http://blog.csdn.net/ynnmnm/article/details/44983545 附：安卓设备市场份额的分布（谷歌统计）https://developer.android.com/about/dashboards/index.html","raw":null,"content":null,"categories":[],"tags":[{"name":"纹理","slug":"纹理","permalink":"http://yoursite.com/tags/纹理/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]},{"title":"酷跑游戏","slug":"kupao","date":"2017-08-16T08:49:39.000Z","updated":"2020-10-13T02:27:21.193Z","comments":true,"path":"2017/08/16/kupao/","link":"","permalink":"http://yoursite.com/2017/08/16/kupao/","excerpt":"一、对这个项目的初步认识：1、游戏跑起来是怎么样的：","text":"一、对这个项目的初步认识：1、游戏跑起来是怎么样的： 2、怎么打开这个工程2.1工程下载：【附】：项目下载资料为网络搜集所得，仅供学习研究，严谨用于商业行为，请下载后于24小时之内删除。 链接: http://pan.baidu.com/s/1bp5yiSn 密码: 6t4e 2.2怎么打开这个工程1、安装unity （mac上面打开会有问题 我在windows unity 4.7版本打开）:安装教程见我的博客：https://wlxklyh.github.io/2017/07/30/unity_study/ 2、新建一个工程 然后双击下载到的unitypackage就会导入 之后打开MainScene 然后点击运行即可3、工程代码的结构 4、工程代码的入口看到Game这个object挂载了很多的脚本组件我们接下来会看这些代码，从名字来看 重点看GameManager DataManager Mission Manager GUIManager 5、第三方库UI用了NGUI 二、阅读代码1、先看GameManager这个是游戏管理的类，从这里开始阅读， 2、AudioManager音效管理音效的配置都在Unity编辑器里面配置这些音乐 见图片（看MainScene里面Game这个对象 里面挂载一个脚本组件AudioManager）这个类比较脚本 提供两个接口给外部调用playBackgroundMusic 播放背景音乐playSoundEffect 播放音效 这里用枚举列出了几种音效 3、CoinGUICollection硬币收集管理的类4、DataManager数据管理Unity提供PlayerPrefs存储玩家的数据 5、GUIClickEventReceiver 点击事件的接收首先我们先看下项目是怎么实现事件点击的 然后看下其他的方法 然后稍微知道NGUI怎么实现点击的 5.1. 项目中响应点击1.这里用到了一个脚本叫做 GUIClickEventReceiver 然后项目中的所有button都挂载了这个脚本.2.NGUI的Button被点击了会响应这个Button挂载的脚本的OnClick函数3.所以，所有的button都会响应GUIClickEventReceiver 的OnClick函数 看到这个函数里面做了分发这些响应事件 5.2 NGUI响应事件的方法：http://www.xuanyusong.com/archives/2390这个链接里面用的事件和委托的方法就可以像观察着模式那样处理如果是本项目这样的就会在一个地方处理 不够解耦 但是又统一直观 5.3 NGUI响应事件:https://my.oschina.net/u/185335/blog/380414原理都在NGUI 的dll里面 6、GUIManager 界面管理这个界面管理也有点类似GUIClickEventReceiver 统一处理比较直观统一左边的图是MainScene里面的截图 包括所有的Panel 下一幅图是GUIManager里面的panel成员 showGUI这个函数用来显示具体哪个面板的 在按钮响应分发用的挺多 点击一个按钮就打开相应的面板 设置游戏UI 像分数这些：setInGameScore 金币数量：setInGameCoinCount显示教程：showTutorial刷新分数：refreshStoreGUI 7、InputController 输入管理需要了解下Unity 里面的Inputhttp://blog.csdn.net/lingyun_blog/article/details/41451565 Unity为我们预设了一些输入： 回到项目中的InputController，看到Update函数里面，用GetButtonUp判断是否点击了Jump函数 if (Input.GetButtonUp(“Jump”)) { playerController.jump(false); } 到此为止，这个类我们可以看到是怎么得到键盘鼠标的输入的 然后再这个类去把事件传给playerObeject 让它响应相应的动作 8、MissionManager 关卡管理9、PowerUpManager 玩家buff管理类能力加强的管理类： DoubleCoin双倍金币, CoinMagnet金币磁铁, Invincibility无敌, SpeedIncrease加速, NoneactivatePowerUp激活哪个加强buff dataManager.getPowerUpLength(powerUpType);时间在DataManager里面配置用协程来实现加强buff的维持的时间activatePowerUp函数激活 然后开始协程StartCoroutine(“runPowerUp”);yield return new WaitForSeconds(activePowerUpData.duration);等待相应的时间 然后结束强化deactivatePowerUp(); 10、SocialManager社交管理Facebook Twitter的功能 11、StaticData 静态数据在unityEditor里面设置 12、玩家的转向跳跃这个要看这几个脚本PlayerController.cs InputController.cs 我们先确定一个重要的点：我们看到人物前进实际是把物体向后移动实现的，人物会相对当前位置跳跃 沿着Y轴移动 1、先看下InputController这个脚本看到 up按钮和space按钮都预设为跳上面两张图是这个工程设置了按键对应的名称：Jump Slide LeftTurn 下面我们分别说人物三类动作的响应函数这个是控制输入的（1）人物可以跳跃 下滑 攻击：InputController的Update()函数 if (Input.GetButtonUp(“Jump”)) { playerController.jump(false); } else if (Input.GetButtonUp(“Slide”)) { playerController.slide(); } else if (Input.GetButtonUp(“Attack”)) { playerController.attack(); } （2）人物可以左转向 右转向（3）游戏中有三个轨道左中右轨道，左方向键可以向左移动到最左的轨道，右方向键可以向右移动到最右的轨道（2）（3）的代码一起看LeftTurn LeftSlot用的按键是同一个 都是a和左方向键 如果playerController.turn返回true就不会执行playerController.changeSlots代码了这里可以看出玩家左移用playerController.changeSlots代码 左转用playerController.turn if (Input.GetButtonUp(&quot;LeftTurn&quot;)) { hasTurned = playerController.turn(false, true); } else if (Input.GetButtonUp(&quot;RightTurn&quot;)) { hasTurned = playerController.turn(true, true); } // can change slots if the player hasn&apos;t turned if (!hasTurned) { if (Input.GetButtonUp(&quot;LeftSlot&quot;)) { playerController.changeSlots(false); } else if (Input.GetButtonUp(&quot;RightSlot&quot;)) { playerController.changeSlots(true); } } playerController.changeSlotsinfiniteObjectGenerator.slotDistance这个是unity编辑器里面配置是2 两个跑道之间的距离是2targetSlotValue = (int)currentSlotPosition infiniteObjectGenerator.slotDistance;这个值就是目标的跑道的偏移这里更新目标位置updateTargetPosition(targetRotation.eulerAngles.y);看下这个函数updateTargetPosition的这两句targetPosition.x += targetSlotValue Mathf.Cos(yAngle Mathf.Deg2Rad); targetPosition.z += targetSlotValue -Mathf.Sin(yAngle Mathf.Deg2Rad);把targetSlotValue 换算成左边偏倚 y轴的转向也就是人物中心轴转向 如果一开始游戏 Y转向是0度 那么Mathf.Cos(yAngle Mathf.Deg2Rad)是1 -Mathf.Sin(yAngle * Mathf.Deg2Rad);是0 然后targetSlotValue 的偏移都是X的便宜 Z不用偏移 同理可以想像下 如果向左转了90 之后 偏移就 playerController.turn 获取目标转向：Vector3 direction = platformObject.getTransform().right * (rightTurn ? 1 : -1); 得到目标的转向：targetRotation = Quaternion.LookRotation(direction); 然后在LateUpdate里面真正的插值转职到targetRotation if (thisTransform.rotation != targetRotation) { thisTransform.rotation = Quaternion.RotateTowards(thisTransform.rotation, targetRotation,Mathf.Lerp(slowRotationSpeed, fastRotationSpeed, Mathf.Clamp01(Quaternion.Angle(thisTransform.rotation, targetRotation) / 45))); } 这里查下RotateTowards函数是旋转到目标角度 Mathf.Lerp函数是获得插值 插值就可以实现平滑的旋转 13、InfiniteGenerator和InfiniteObjects文件夹下面的脚本MainScene里面有个Obeject叫InfiniteObject 这些无限的场景和物体都是在这个object下面 分成五类物体：（1）obstacles：障碍物（2）scene：场景（3）powerups：强化道具（4）platforms：底板（5）coins：硬币 1、InfiniteObjectGenerator 生成器函数入口，调用堆栈： PlayerController::LateUpdate() InfiniteObjectGenerator::moveObjects() InfiniteObjectGenerator::spawnObjectRun() 我们看下spawnObjectRun函数： 有个函数在移动整个场景moveObjects 这个是被PlayerController的LateUpdate函数调用moveObjects里面来调用spawnObjectRun 从而不断生成 我们看下moveObjects这个函数 for (int j = 0; j &lt; (int)ObjectLocation.Last; ++j) {这个循环是移动所有的物体 infiniteObject = infiniteObjectHistory.getTopTurnInfiniteObject(i == 0);这句获取第一个物体判断是否要销毁 spawnObjectRun(true);这句调用了生成的函数 spawnObjectRun这个函数的前半部分是生成路径 后半部分是生成一个转向 附vs2015断调试unity项目http://www.itcast.cn/news/20151229/1437047587.shtml","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"unity镜头控制脚本","slug":"unity镜头控制脚本","date":"2017-08-10T00:00:00.000Z","updated":"2020-10-13T02:27:21.309Z","comments":true,"path":"2017/08/10/unity镜头控制脚本/","link":"","permalink":"http://yoursite.com/2017/08/10/unity镜头控制脚本/","excerpt":"学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面：","text":"学习shader的时候 想在运行时去从各个角度查看模型，所以参考网上已有代码 加上一个手型工具 就得到这份镜头控制脚本，代码在下面： 看代码即可： using UnityEngine;using System.Collections; public class CameraController : MonoBehaviour {// 【使用说明】：参考了网上代码 ~~// 1、拖拽到摄像头 作为摄像头的组件// 2、运行的时候：// （1）镜头旋转 右键点击着屏幕 然后移动鼠标 即可旋转屏幕// （2）镜头缩放 滚轮控制缩放镜头// （3）手型工具 就像scene里面的手型工具一样 滚轮点击着拖拽屏幕// （4）镜头复原 空格键就会复用镜头 ///【1】用于计算的变量 //旋转变量; private float m_deltX = 0f; private float m_deltY = 0f; //摄像机原始位置 和 旋转角度 给复原使用 private Vector3 m_vecOriPosition; private Quaternion m_vecOriRotation; //手型工具：上次点击屏幕的位置 private Vector3 m_vecLasMouseClickPosition; ///【2】用于控制幅度的变量 //缩放幅度; public float m_fScalingSpeed = 10f; //镜头旋转幅度; public float m_fRotateSpeed = 5f; //手型工具幅度; public float m_fHandToolSpeed = -0.005f; void Start() { m_vecOriRotation = camera.transform.rotation; m_vecOriPosition = camera.transform.position; } void Update () { //（1）旋转镜头 鼠标右键点下控制相机旋转; if (Input.GetMouseButton(1)) { m_deltX += Input.GetAxis(&quot;Mouse X&quot;) * m_fRotateSpeed; m_deltY -= Input.GetAxis(&quot;Mouse Y&quot;) * m_fRotateSpeed; m_deltX = ClampAngle(m_deltX, -360, 360); m_deltY = ClampAngle(m_deltY, -70, 70); camera.transform.rotation = Quaternion.Euler(m_deltY, m_deltX, 0); } //（2）镜头缩放 //鼠标中键点下场景缩放; if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) != 0) { //自由缩放方式; m_fScalingSpeed = Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * 10f; camera.transform.localPosition = camera.transform.position + camera.transform.forward * m_fScalingSpeed; } //（3）手型工具 if (Input.GetMouseButtonDown (2)) { m_vecLasMouseClickPosition = Input.mousePosition; } else if (Input.GetMouseButton (2)) { Vector3 NowHitPosition = Input.mousePosition; Vector3 offsetVec = NowHitPosition - m_vecLasMouseClickPosition; offsetVec = camera.transform.rotation * offsetVec; camera.transform.localPosition = camera.transform.localPosition + offsetVec * (m_fHandToolSpeed); m_vecLasMouseClickPosition = Input.mousePosition; } //(4)相机复位远点; if (Input.GetKey(KeyCode.Space)) { m_deltX = 0f; m_deltY = 0f; m_deltX = ClampAngle(m_deltX, -360, 360); m_deltY = ClampAngle(m_deltY, -70, 70); m_fScalingSpeed = 10.0f; camera.transform.rotation = m_vecOriRotation; camera.transform.localPosition = m_vecOriPosition; } } //规划角度; float ClampAngle(float angle, float minAngle, float maxAgnle) { if (angle &lt;= -360) angle += 360; if (angle &gt;= 360) angle -= 360; return Mathf.Clamp(angle, minAngle, maxAgnle); } }","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"Unity安装->入门->工程学习->shader","slug":"unity_study","date":"2017-07-30T12:49:39.000Z","updated":"2020-10-13T02:27:21.285Z","comments":true,"path":"2017/07/30/unity_study/","link":"","permalink":"http://yoursite.com/2017/07/30/unity_study/","excerpt":"总体的思维导图通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。","text":"总体的思维导图通过下面一张图，大概的知道一个学习的方向和流程。对于这篇文章讲的是第一个部分，入门，初次接触unity。 一、安装1、安装教程（windows）mac就比较简单 官网下载dmg就可以安装使用了我用下面图中的两个文件完成安装，一个是安装文件（4.7），一个是破解，然后根据下面链接完成安装 http://jingyan.baidu.com/article/90895e0f959c7564ec6b0bfb.html 2、需要的文件（百度网盘分享）http://pan.baidu.com/s/1slFHeFz 分享的文件里的东西有： 【安装使用】：Unity 4.7.1安装文件 【安装使用】：Unity 4.x pro Patch.exe 【入门使用】：《unity4.x从入门到精通》 【入门使用】：简单的工程（微信飞机游戏）： 【进一步了解使用】：RPG游戏的简单的工程 【shader学习使用】：《Unity Shader入门精要》 3、安装结果使用a.Unity 4.7.1安装文件 b.Unity 4.x pro Patch.exe 然后用上上面的教程链接就可以完成windows unity的安装 打开如下： 二、入门学习：1、开始我找了本书看《unity4.x从入门到精通》：《unity4.x从入门到精通》http://pan.baidu.com/s/1slFHeFz 2、《unity4.x从入门到精通》读书的记录：第一章 （可跳过）第一章 没什么干货 可以直接跳过 第二章 （重点看2.1 2.2+实操一下） 刚接触的unity的可以按照第二章说的去操作一下 感受一下unity的一些功能 想贪快的就看2.1 、2.2部分即可 后面的用到再查阅 快捷键部分 等到基本入门了 再来看一遍 会比较受用的感觉 第三章 （粗略看） 第三章看下 不用纠那么细致 第四章 （重点看+操作） 第四章书讲的是怎么写代码的 看完第四章就会输出hello world截取两张图 后面5-17章的当作工具书看12章 到16 是针对开发的介绍 17章 进阶 ： 网络 3、大致的浏览了《unity4.x从入门到精通》 前四章之后带着几个疑问去分类学习：3.1、C#代码跟unity怎么关联起来？ 书中13章1、C#脚本的规则（1）凡事需要添加到游戏对象的C#脚本类都是需要直接或者间接的继承 MonoBehaviour 如果在unity添加脚本 unity会自动填充继承MonoBehaviour的代码 如果是自己新建一个文件 然后在unity从拖拽添加component 这样是不会成功的（后面会说unity怎么添加C#文件） （2）继承了MonoBehaviour的类 都会有Start 和 Awake函数的继承 一般使用Start和Awake来初始化 不使用构造函数的原因是unity中无法确定构造函数的顺序。这里我觉得有个原因是：unity会把所有绑定在对象身上的类实例化 然后才可以GetComponent() 例如：下面的操作如果在构造函数中做 可能PlayerAttack这个没有实例化 那么获取不到 所以把初始化工作放在Start中 （3）类名和脚本文件名相同 （4）协同函数Coroutines 返回类型必须是Ienumerator （5）C#不支持自定义命名空间 2、C#脚本在unity编辑器中关联对象（十三章有详细介绍）1、创建脚本的方法： 2、创建完之后的编辑：这里可以修改用MonoDevelop的编辑器 或者用Vs2012作为代码编辑 3、关联到对象去（3.1）添加一个gameobject（3.2） 然后给gameObject添加脚本 在Unity中，继承MonoBehaviour的C#脚本都被看作一个Component 游戏对象可以理解为一个容纳各种类型component的容器 游戏对象的所有component一起决定了这个对象的行为表现 这个对象被添加到scene中之后 然后点击build and run 之后这个脚本的Start函数就会被调用一起 可以在这里输出 hello world 这就算是unity的hello world 3、怎么获取别的对象以及他的component使用函数 GameObject.Find null则是找不到 根据类名使用函数GameObject.FindWithTag还有在unity编辑器中拖拽 查看数组的表13-6 表13-7 表13-8 表13-9 三、工程学习：看了《unity4.x从入门到精通》 简单操作unity之后 我上网找几个简单的游戏demo来看下，这样我觉得会比较快上手。 1、微信飞机大战工程下载地址：http://pan.baidu.com/s/1slFHeFz （网上找的工程）这个比较容易看懂 下面说明的过程：（1）背景移动 –&gt;（2）敌机出生–&gt;（3）自己的飞行==》 ==》 1、初看这个工程只有一个场景scene预制体有这些脚本是这些 2、分几个部分看2.1、scene1.里面有个 Main Camera 点击它然后看导航栏Inspector2.Main Camera里面有一些component组件 其中Camera 去修改size view port然后运行看下结果3.除了Main Camera 这个Scene里面还有一些飞机（hero） 背景（bg） 还一些不是UI的东西（bombManager） 上面大概的了解到，在这个Scene里面拖拽了一些物件 还有一个摄像机 把这些物件投影到屏幕中，到目前为止，我们大概知道是怎么得到游戏的静态界面的，但是游戏是怎么动起来的还不知道。接下来脚本就是讲怎么动起来的。 2.2、脚本 代码入口，没有一个明确的Main函数入口下面按照顺序说下（1）背景移动 （2）怎么生成敌机 （3）怎么控制自己的战机（1）背景移动scene里面有个object叫bg 然后再点击其中一个background查看导航栏可以看到每个background都挂在了一个脚本组件 BackgroundTransform.cs 这个脚本就是控制不背景移动的 看到BackgroundTransform这个脚本 两个背景来控制屏幕的背景交替向下移动12345678910111213public class BackgroundTransform : MonoBehaviour &#123; public static float moveSpeed = 2f; // Update is called once per frame void Update () &#123; this.transform.Translate( Vector3.down * moveSpeed * Time.deltaTime ); Vector3 postion = this.transform.position; if(postion.y&lt;=-8.52f)&#123; //有两个背景在交替滚动 如果有一个滚动到屏幕外面则改动显示 this.transform.position = new Vector3(postion.x,postion.y+8.52f*2,postion.z ); &#125; &#125;&#125; （2）怎么生成敌机scene里面有个叫spawn的东西 这个spawn十个空object 里面挂了一个spawn.cs脚本组件【代码如下】： 地机的行为就看模型上面挂的脚本组件Enemy.cs （3）怎么控制自己的战机同样的在hero这个上面挂了Hero.cs的脚本组件 然后具体就看里面的代码 2、RPG游戏然后再找个复杂点的游戏工程来看 1、初看工程 工程下载地址：http://pan.baidu.com/s/1slFHeFz（网上找的工程） 工程的脚本目录 2、工程代码查看看下怎么把这个人物控制方向运动起来的 1.打开03_play这个scene 然后拖拽一个Magician模型到scene中先在Prefabs文件夹中找到Magician看模型有什么挂件 Magician挂了Character Controller这个控制组件这个是角色控制器 可以对角色做移动的操作 在playermove脚本里面用到 Magician还挂了PlayerDir PlayerMove PlayerAnimation PlayerState PlayerAttack等脚本来实现模型的行为看下PlayerMove的update函数这里判断如果距离大于0.3f则会移动 从Magician引发的问题： 2.1、移动的时候有个targetPosition 这个是怎么来的？targetPosition 是PlayerDir.cs这个里面的成员PlayerDir.cs里面会计算鼠标点击屏幕的位置发出的射线的碰撞结果 如果是地面那么修改这个玩家的朝向 2.2、又引发一个问题鼠标怎么会变样？我们看到03_play这个scene有个object叫GameSetting 这个是一个纯粹为了挂脚本用的object我们看到这个CursorManager就是我们在游戏中的鼠标的管理类 2.3、模型怎么会动起来呢？打开03_play这个scene 然后拖拽一个Magician模型到scene中 然后在菜单栏window animation打开animation窗口 然后可以选择已经做好的动作 attack1 然后点击播放 现在我们知道动作可以预先做好 然后再代码中调用 我们看下代码是怎么调用的PlayerAnimation.cs这个脚本 根据一个状态去 播放动画animation.CrossFade(animName); 1234567891011121314151617// Update is called once per frame void LateUpdate () &#123; if (attack.state == PlayerState.ControlWalk) &#123; if (move.state == ControlWalkState.Moving) &#123; PlayAnim(&quot;Run&quot;); &#125; else if (move.state == ControlWalkState.Idle) &#123; PlayAnim(&quot;Idle&quot;); &#125; &#125; else if (attack.state == PlayerState.NormalAttack) &#123; if (attack.attack_state == AttackState.Moving) &#123; PlayAnim(&quot;Run&quot;); &#125; &#125; &#125; void PlayAnim(string animName) &#123; animation.CrossFade(animName); &#125; 这个项目的运行 之后看下怎么改改这个项目 不懂的再google 或者再去细看unity的一些用法 或则C#的用法 四、Unity Shader学习A、我学习的三个点 1.下载源码中源码下载：https://github.com/candycat1992/Unity_Shaders_Book 2.学习hello world!下面gif是unity shader的hello world! 3.看书照着源码学习 然后实践B、学习随便记录的笔记 1.第一章2.第二章 渲染流水线应用阶段-&gt;几何阶段-&gt;光栅化阶段应用阶段把渲染图元交给几何阶段 2.2CPU 和 GPU 的通信 把数据加载到显存中 设置渲染状态 调用 drallcall 1.把数据加载到显存中硬盘—&gt;内存—&gt;显存顶点数据 法线方向 纹理坐标 2.设置渲染状态vs ps顶点着色器 片元着色器 3.drawcall 2.3GPU 流水线顶点着色器把顶点坐标转换到齐次裁剪坐标系得到归一化的设备坐标 NDCopengl unity的 NDC 是-1 1屏幕映射 转换到屏幕坐标系屏幕坐标系Opengl 是左下角 3.第三章 Unity shader基础3.1 创建shader的常见流程 创建一个材质 创建一个unity shader 并把它赋给上一步中创建的材质 把材质赋给要渲染的对象 在材质面板上（选中材质然后查看导航栏）调整shader的属性 3.2 shader labGLSL是opengl的shader语言 Directx的shader语言是HLSL shader lab的就是 unity shader的shader语言可以细看下这个章节 熟悉下语法 4 学习 Shader 所需的数学知识一些基础的知识都是大概知道 可以等到要用到的时候再去复习一些空间 M 模型空间 W 世界空间 V 摄像机空间 NDC 归一化空间 5 开始学习 Shader5.2 最简单的片元着色器 顶点着色器5.2.2 unity支持的语义：POSITION，TANGENT，NORMAL，TEXCOORD0，TEXCOORD1，COLOR 5.2.3 顶点着色器和片元着色器之间的通信：声明一个新的结构体v2f v2f可用于定点着色器和片元着色器之间传递信息 5.3.1内置包含的文件在后面的学习中 总是会用到一些内置的文件需要include一下 类似C++的include 5.5 Debug技巧 把想知道的值赋值到某个颜色 通过屏幕上显示的颜色来判断一个值 还可以找到一个简单的取色脚本 ColorPicker.cs 高级的：Visual Studio Graphics Debugger Unity里面的帧调试器 6 Unity 中的基础光照6.2 进入摄像机的光分成4个部分 自发光：本身辐射量 如果没有全局光照技术 自会影响自己的辐射量 高光反射：（我觉得是完全镜面反射）光源的完全镜面反射方向散射多少辐射量？？ 是镜面反射的散射？？ 漫反射：这个就是光源的漫反射 环境光：其他所有的间接光照 计算高光反射：Phong 模型来计算高光反射部分： 6.4 光照实现（1）Properties定义一个颜色值（2）LightMode标签是 Pass 标签的一种 只有定义了正确的 LightMode 我们才能得到一些 Unity的内置光照变量Tags { “LightMode”=”ForwardBase” } （3）还是之前的 CGPROGRAM ENDCG （4）为了用到 Unity的内置变量‘’’ #include “Lighting.cginc” “‘ （5）逐顶点 着色器 逐顶点漫反射：有锯齿 应该是因为处理是每个片元的顶点 所以不精细 逐像素漫反射：无锯齿 但是黑面太黑 都是一个色 黑色 半伯兰特模型：无锯齿 黑面有渐变c = c m (0.5 (n I) + 0.5)7 基础纹理 记住这个 ： o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;7.1.2 纹理取样fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; 7.2 凹凸映射不改变顶点 改变的是绘制法线纹理 normal map 7.2.1高度纹理存储的是强度值 这个通过高度来计算法线颜色越浅越突 反而凹 7.2.2法线纹理法线的向量分量是 -1 到1所以 pixel = (noamal+1)/2normal = (pixel * 2) - 1 这种纹理称为是模型空间的法线纹理 我恩会采用另外一种坐标空间 切线空间 我们用模型顶点的切线空间来存储法线 对于每个顶点都有一个属于自己的切线空间 这个切线空间的原点就是该顶点本身 z 轴就是顶点的法线 x 轴是顶点的切线方向 我们的法线纹理 存储的是 法线在各自的切线空间的向量 大部分都是浅蓝色的原因是 0 0 1映射到0 1就是0.5 0.5 1（浅蓝色） 0 0 1就是 z 轴 大部分的法线都是跟切线空间的 z 轴同方向 一种是模型空间下的法线纹理 一种是切线空间下的法线纹理 模型空间存储的优点： 实现简单 直观。生成简单 提供平滑的边界 模型空间可以生成平滑 切线空间优点： 自由度高 模型空间的是绝对法线信息 应用到不同网格都有合理的效果 可进行 UV 动画 我们通过移动一个纹理的 UV 坐标来实现凹凸移动的效果 可压缩 只此处 xy z 可以推倒得到 7.2.3 实践 一种在切线空间下进行光照计算 把光照方向、视角方向变换到切线空间下 ：效率比较高 在顶点着色器可以完成 光照和视角的转换 第二种要堆法线纹理取样 需要在片元着色器中变换 我觉得应该是片元的数量大于顶点的数量所以转换需要很多有时我们要在世界空间下进行一些计算 例如在 Cubemap进行环境映射 需要使用世界空间下进行一些计算 （这个 cubemap 不知讲啥） 另外一种是在世界坐标空间下进行光照计算 我们要把切线空间下的法线防线转换到世界空间下： 在切线空间下计算思路：在片元着色器中得到纹理采样的切线空间下的法线 然后再与切线空间下的视角方向 光照方向进行计算注：float4 texcoord : TEXCOORD0; 传入的是float4 xy 是原因的纹理 UV zw 是法线纹理 uv 7.2.4 unity 法线纹理类型法线纹理会根据平台被压缩使用 unpackNormal 函数取解压普通纹理的话 是4个通道都是不能舍弃 如果是法线纹理 那么只有ag 是需呀的 br 是不需要的 用 DXT5nm 可以升内存空间。Create from Grayscale 是凹凸映射的方法 高度图 7.3渐变纹理7.4遮罩纹理使用其中某个（或者几个）通道做乘法 如果通道为0 可以保证表面不受该属性影响 8透明效果unity 先渲染 Background 然后渲染 Geometry 大多数的不透明物体 前面都是开启深度测试和深度写入 之后渲染 AlphaTest 这个是透明物体 需要排序 从远到近 然后进行渲染 8.3透明度测试用一个阀值决定 8.4透明度混合Blend 内置的混合模式命令Blend off 关闭混合Blend SrcFactor DstFactorsrccolor SrcFactor + dstcolor DstFactor = Target 8.6.1 混合等式和参数现在有 源颜色 S 和目标颜色 D 现在想要得到输出颜色 O 就必须使用一个等式来计算，这个就是混合等式我们会用两个混合等式 一个用于混合 RGB 一个混合 A 通道 每个等式要两个因子 一共四个因子。 中级篇 ####9 更复杂的光照Forward Rendering Path、Deferred Rendering Path Vertext Lit Rendering Path 顶点照明渲染路径：是对硬件配置要求最好 运算性能最高的 跳过。。。 10 高级纹理10.1立方体纹理立方体纹理是环境映射的一种实现方法包含6张图像 采样的时候是用三维的坐标 使用立方体纹理的好处 实现简单快捷 得到的效果好 缺点是 如果当场景引入了新的物体 光源 或者物体在发生移动时 我们就需要重新生成 立方体纹理 可以反射环境 但不能反射自己 10.1.1 天空盒子windows -lighting 里面设置 skybox 10.1.2折射折射 是用光照计算函数 然后用折射函数混合反射光 10.2渲染纹理10.2程序纹理11 让画面动起来11.1 unity shader 中的内置变量_Time float4 场景加载开始所经过的实际_SinTime 正弦值_CosTime 余弦值unity_DeltaTime 11.2 纹理动画 序列帧动画：记住 UV 纹理坐标是左下角是原点 滚动的背景：修改 UV 纹理坐标 对两张纹理取样 然后混合","raw":null,"content":null,"categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"}]},{"title":"首次用gitpage","slug":"首次使用gitpage","date":"2016-08-09T22:49:39.000Z","updated":"2020-10-13T02:27:21.309Z","comments":true,"path":"2016/08/09/首次使用gitpage/","link":"","permalink":"http://yoursite.com/2016/08/09/首次使用gitpage/","excerpt":"","text":"总体上感觉不错 十分的方便，可以在多个平台使用 发布方便 因为用markdown所以格式不用担心 而且在什么平台都可以编写 写完上传github 之后用我的macbook 更新下编写的markdown 之后在macbook上面发布即可 有些格式macdown看到是可以的 但是html又不可以了","raw":null,"content":null,"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}